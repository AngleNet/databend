---
title: Versioned Config
description: RFC for versioned config
---

- RFC PR: [datafuselabs/databend#5324](https://github.com/datafuselabs/databend/pull/5324)
- Tracking Issue: [datafuselabs/databend#5297](https://github.com/datafuselabs/databend/issues/5297)

# Summary

The versioned configuration will allow us to iterate quickly while avoiding breaking the environment.

# Motivation

While early birds are starting to deploy databend by themselves, it's time for us to establish some contracts between users. We should allow users to upgrade their deployments without breaking backward compatibility. In this RFC, we will focus on `config`.

`config` I mentioned here including:

- config file that is read by `databend-query` and `databend-meta`.
- config env that read by `databend-query` and `databend-meta`
- application args that are accepted by `databend-query` and `databend-meta`
- protobuf messaged that generated by `databend-query` (stored inside `databend-meta`)

Out of scope:

- Tools like `fuzz` and `metactl` are not covered by this RFC.
- Command-line UX of `databend-query` and `databend-meta` is another topic. We will not cover it in this RFC.
- Config input/output by SQL/HTTP Rest API are not covered (for example, the output of table `system.config`)

> For convenience, I will use `databend` to refer to `databend-query` and `databend-meta`.

With this RFC, our users will upgrade their deployments without breaking. Old configs should always work along with the new implementations.

# Guide-level explanation

With this RFC, users will have a new field called `version` at the top of the config file. The value of the version is an integer and defaults to `0`. If the version is not specified, we will load it as` 0`.

All config files, env, and args will be supported:

- config file: `version=42`
- config env: `export CONFIG_VERSION=42`
- args: `--config-version=42`

Suppose compatible changes happened as a new config entry was added. databend will make sure that the entry has a default value.

Suppose incompatible changes happened, like config been removed/renamed/changed. databend increases the config version. The older version will still load by the specified version and be converted to the latest config internally.

# Reference-level explanation

Inside databend, we will split config into `inner` and `outer`:

**`inner`**

Config instances used inside databend. All logic **SHOULD** be implemented towards `inner` config.

**`outer`**

Config instances used as the front office of databend. They will have different versions and transform into an `inner` config. Other modules **SHOULD** not depend on `outer` config.

Take `query` for example:

The inner config of the query will be like this:

```rust
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
#[serde(default)]
pub struct Config {
    pub query: QueryConfig,
    pub log: LogConfig,
    pub meta: MetaConfig,
    pub storage: StorageConfig,
    pub catalog: HiveCatalogConfig,
}
```

The outer config of the query will be like this:

```rust
#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize, Parser)]
#[clap(about, version, author)]
#[serde(default)]
pub struct ConfigV1 {
    #[clap(long, short = 'c', default_value_t)]
    pub config_file: String,
    #[clap(long="config-version", default_value_t)]
    pub config_version: u64,

    #[clap(flatten)]
    pub query: QueryConfigV1,

    #[clap(flatten)]
    pub log: LogConfigV1,

    #[clap(flatten)]
    pub meta: MetaConfigV1,

    #[clap(flatten)]
    pub storage: StorageConfigV1,
    
    #[clap(flatten)]
    pub catalog: HiveCatalogConfigV1,
}
```

The users have to maintain the `outer` config.

For example: `common-io` should provide `inner` config `StorageConfig`. If `query` wants to include `StorageConfig` inside `QueryConfig`, `query` needs to:

- Implement versioned `outer` config for `StorageConfig` called `v1::StorageConfig`.
- Implement `Into<StorageConfig> for v1::StorageConfigV1`.
- Refer `StorageConfig` in `QueryConfig`,
- Refer `v1::StorageConfig` and `v1::QueryConfig`.

# Drawbacks

## Maintenance burden

Introducing a versioned config will increase the complexity of the config handler.

# Rationale and alternatives

## Why not use string as version?

Using `u64` is the simplest way. We don't want to introduce concept semver into our config. Think about the version of `docker-compose`! Do you remember which version to use for `docker-compose.yml` without visiting its documents?

## Why use `serde` and related tools?

The most important thing is that RFC intends to split `inner` and `outer` config instances. Make `inner` as simple as possible and leave the userland interactive works for `outer` to handle.

`serde` doesn't work in this way.

## How to work with protobuf used by `meta`?

As described in the reference, the config used by `protobuf` is another `outer` config. It should handle versions by itself. Based on the current status of databend `common-proto-conv`, we will keep all fields until we decide to increase `OLDEST_COMPATIBLE_VER`.

# Prior art

None, this RFC is the first try for backward config compatibility.

# Unresolved questions

None.

# Future possibilities

None.
